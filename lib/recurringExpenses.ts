import { Expense } from "@/models/Expense";
import { RecurringExpense } from "@/models/RecurringExpense";

function monthStart(date: Date) {
  return new Date(date.getFullYear(), date.getMonth(), 1);
}

function nextMonth(date: Date) {
  return new Date(date.getFullYear(), date.getMonth() + 1, 1);
}

function clampDay(year: number, month1to12: number, day: number) {
  const last = new Date(year, month1to12, 0).getDate();
  return Math.min(Math.max(1, day), last);
}

export async function ensureRecurringExpensesUpToCurrent() {
  const now = new Date();
  const currentMonth = monthStart(now);
  const templates = await RecurringExpense.find({ active: true }).lean();

  let opsCount = 0;
  let templateCount = 0;
  const ops: Array<{
    updateOne: {
      filter: Record<string, unknown>;
      update: { $setOnInsert: Record<string, unknown> };
      upsert: true;
    };
  }> = [];

  for (const template of templates) {
    templateCount += 1;
    const start = monthStart(new Date(template.startDate));
    const templateEnd = template.endDate ? monthStart(new Date(template.endDate)) : null;
    const end = templateEnd && templateEnd < currentMonth ? templateEnd : currentMonth;
    if (start > end) continue;

    let cursor = start;
    while (cursor <= end) {
      const y = cursor.getFullYear();
      const m = cursor.getMonth() + 1;
      const d = clampDay(y, m, Number(template.dayOfMonth || 1));
      const expenseDate = new Date(y, m - 1, d);

      ops.push({
        updateOne: {
          filter: {
            recurringTemplateId: template._id,
            recurringYear: y,
            recurringMonth: m,
          },
          update: {
            $setOnInsert: {
              date: expenseDate,
              amount: template.amount,
              category: template.category,
              vendor: template.vendor || "",
              note: template.note || "",
              projectId: template.projectId || null,
              isAutoGenerated: true,
              recurringTemplateId: template._id,
              recurringYear: y,
              recurringMonth: m,
            },
          },
          upsert: true,
        },
      });
      opsCount += 1;
      cursor = nextMonth(cursor);
    }
  }

  if (ops.length) {
    await Expense.bulkWrite(ops, { ordered: false });
  }

  return { templates: templateCount, attemptedMonths: opsCount };
}

